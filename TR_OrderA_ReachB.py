import sys
import time
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QTextEdit,
    QLineEdit, QPushButton, QComboBox, QTimeEdit
)
from PyQt5.QtCore import Qt, QTimer, QCoreApplication, QTime
from Comms_Class import InitPlusCheck, get_current_price
from Comms_Class import CpOptionMst  # Ïù¥ Ï§ÑÏùÄ Ïã§Ï†ú ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏúºÎ©¥ Ï†úÍ±∞ Í∞ÄÎä•
from Comms_Class import CpFutureOptionOrder
from Comms_Class import send_telegram_message  # ÌÖîÎ†àÍ∑∏Îû® Î©îÏãúÏßÄ Ìï®Ïàò ÏûÑÌè¨Ìä∏


# Î∂ÑÌï† Îß§Ïàò/Îß§ÎèÑ Í∏∞Îä• ÏÑ§Î™Ö:
# Ìä∏Î¶¨Í±∞ Í∞ÄÍ≤©Ïóê ÎèÑÎã¨ÌïòÎ©¥ ÏÑ§Ï†ïÎêú Ï¥ù Ï£ºÎ¨∏ ÏàòÎüâÏùÑ 3Îì±Î∂ÑÌïòÏó¨ Ï£ºÎ¨∏ÏùÑ Ïã§ÌñâÌï©ÎãàÎã§.
# Îß§Ïàò Ï£ºÎ¨∏ ÏãúÏóêÎäî Ï≤´ Î≤àÏß∏ Ï£ºÎ¨∏ÏùÄ Ìä∏Î¶¨Í±∞ ÏãúÏ†êÏùò Í∞ÄÍ≤©ÏúºÎ°ú,
# Îëê Î≤àÏß∏ Ï£ºÎ¨∏ÏùÄ Ï≤´ Î≤àÏß∏ Í∞ÄÍ≤©Î≥¥Îã§ 0.01 Ï¶ùÍ∞ÄÎêú Í∞ÄÍ≤©ÏúºÎ°ú,
# ÏÑ∏ Î≤àÏß∏ Ï£ºÎ¨∏ÏùÄ Ï≤´ Î≤àÏß∏ Í∞ÄÍ≤©Î≥¥Îã§ 0.02 Ï¶ùÍ∞ÄÎêú Í∞ÄÍ≤©ÏúºÎ°ú ÏãúÎèÑÌï©ÎãàÎã§.
# Îß§ÎèÑ Ï£ºÎ¨∏ ÏãúÏóêÎäî Ï≤´ Î≤àÏß∏ Ï£ºÎ¨∏ÏùÄ Ìä∏Î¶¨Í±∞ ÏãúÏ†êÏùò Í∞ÄÍ≤©ÏúºÎ°ú,
# Îëê Î≤àÏß∏ Ï£ºÎ¨∏ÏùÄ Ï≤´ Î≤àÏß∏ Í∞ÄÍ≤©Î≥¥Îã§ 0.01 Í∞êÏÜåÎêú Í∞ÄÍ≤©ÏúºÎ°ú,
# ÏÑ∏ Î≤àÏß∏ Ï£ºÎ¨∏ÏùÄ Ï≤´ Î≤àÏß∏ Í∞ÄÍ≤©Î≥¥Îã§ 0.02 Í∞êÏÜåÎêú Í∞ÄÍ≤©ÏúºÎ°ú ÏãúÎèÑÌï©ÎãàÎã§.

class FutureOptionApp(QWidget):
    contract_unit = 250000  # ÏòµÏÖò 1Í≥ÑÏïΩ Îã®ÏúÑ Í∏àÏï°

    def __init__(self):
        super().__init__()

        self.setWindowTitle("OrderA_ReachB")
        self.setGeometry(140, 60, 1600, 600)
        self.move(
            QApplication.desktop().screen().rect().center() - self.rect().center()
        )
        self.layout = QVBoxLayout()
        self.log_count = 0  # Î°úÍ∑∏ Ï§Ñ Ïàò Ïπ¥Ïö¥ÌÑ∞
        self.last_log_time = 0  # ÎßàÏßÄÎßâ Î°úÍ∑∏ Í∏∞Î°ù ÏãúÍ∞Ñ Ï¥àÍ∏∞Ìôî
        self.previous_watch_price = None  # Ïù¥Ï†Ñ Í∞êÏãú Í∞ÄÍ≤© Ï¥àÍ∏∞Ìôî

        # ‚úÖ Í∞êÏãú ÏòµÏÖò + Ìä∏Î¶¨Í±∞ Í∞ÄÍ≤© (1Ï§Ñ)
        top_row = QHBoxLayout()
        self.watch_code_input = QLineEdit()
        self.watch_code_input.setPlaceholderText("Í∞êÏãú ÏòµÏÖò ÏΩîÎìú")
        self.trigger_price_input = QLineEdit()
        self.trigger_price_input.setPlaceholderText("Ìä∏Î¶¨Í±∞ Í∞ÄÍ≤©")
        top_row.addWidget(QLabel("Í∞êÏãú ÏòµÏÖò:"))
        top_row.addWidget(self.watch_code_input)
        top_row.addWidget(QLabel("Ìä∏Î¶¨Í±∞ Í∞ÄÍ≤©:"))
        top_row.addWidget(self.trigger_price_input)

        # ‚úÖ Ï£ºÎ¨∏ ÏòµÏÖò + Ï£ºÎ¨∏ Í∏àÏï° + Ï£ºÎ¨∏Ïú†Ìòï + Î≤ÑÌäº (2Ï§Ñ)
        bottom_row = QHBoxLayout()
        self.order_code_input = QLineEdit()
        self.order_code_input.setPlaceholderText("Ï£ºÎ¨∏ ÏòµÏÖò ÏΩîÎìú")
        self.order_amount_input = QLineEdit()
        self.order_amount_input.setPlaceholderText("Ï£ºÎ¨∏ Í∏àÏï° (Ïõê)")
        self.order_amount_input.textChanged.connect(self.format_amount_input)
        self.order_type_combo = QComboBox()
        self.order_type_combo.addItems(["buy", "sell"])

        self.start_button = QPushButton("Î™®ÎãàÌÑ∞ÎßÅ")
        self.stop_button = QPushButton("Ï§ëÏßÄ")
        self.exit_button = QPushButton("Ï¢ÖÎ£å")

        self.start_button.clicked.connect(self.start_trading)
        self.stop_button.clicked.connect(self.stop_trading)
        self.exit_button.clicked.connect(QCoreApplication.quit)

        bottom_row.addWidget(QLabel("Ï£ºÎ¨∏ ÏòµÏÖò:"))
        bottom_row.addWidget(self.order_code_input)
        bottom_row.addWidget(QLabel("Í∏àÏï°:"))
        bottom_row.addWidget(self.order_amount_input)
        bottom_row.addWidget(QLabel("Ïú†Ìòï:"))
        bottom_row.addWidget(self.order_type_combo)

        # ‚úÖ Ï¢ÖÎ£å ÏãúÍ∞Ñ ÏÑ†ÌÉù UI
        time_row = QHBoxLayout()
        self.end_hour_combo = QComboBox()
        self.end_minute_combo = QComboBox()
        self.interval_combo = QComboBox()  # Í∞êÏãú Ïù∏ÌÑ∞Î≤å ÎìúÎ°≠Îã§Ïö¥

        # ÏãúÍ∞Ñ ÎìúÎ°≠Îã§Ïö¥ (00~23)
        for i in range(24):
            self.end_hour_combo.addItem(f"{i:02d}")

        # Î∂Ñ ÎìúÎ°≠Îã§Ïö¥ (00~59)
        for i in range(60):
            self.end_minute_combo.addItem(f"{i:02d}")

        # Í∞êÏãú Ïù∏ÌÑ∞Î≤å ÎìúÎ°≠Îã§Ïö¥ (0~30Ï¥à)
        for i in range(31):  # 0Ï¥à Ìè¨Ìï®
            self.interval_combo.addItem(f"{i:02d}")

        default_end_time = QTime(10, 57, 0)  # Í∏∞Î≥∏ Ï¢ÖÎ£å ÏãúÍ∞Ñ: 10Ïãú 57Î∂Ñ 0Ï¥à
        self.end_hour_combo.setCurrentText(default_end_time.toString("hh"))
        self.end_minute_combo.setCurrentText(default_end_time.toString("mm"))
        self.interval_combo.setCurrentText("03")  # Í∏∞Î≥∏Í∞í 3Ï¥à

        time_row.addWidget(QLabel("Í∞êÏãú Ï¢ÖÎ£å ÏãúÍ∞Ñ:"))
        time_row.addWidget(self.end_hour_combo)
        time_row.addWidget(QLabel("Ïãú"))
        time_row.addWidget(self.end_minute_combo)
        time_row.addWidget(QLabel("Î∂Ñ"))
        time_row.addWidget(QLabel("Í∞êÏãú Ïù∏ÌÑ∞Î≤å:"))
        time_row.addWidget(self.interval_combo)
        time_row.addWidget(QLabel("Ï¥à"))

        # ‚úÖ Î≤ÑÌäº Ìñâ Îî∞Î°ú
        button_row = QHBoxLayout()
        button_row.addWidget(self.start_button)
        button_row.addWidget(self.stop_button)
        button_row.addWidget(self.exit_button)

        # ‚úÖ Î°úÍ∑∏ Ï∂úÎ†•Ï∞Ω
        self.text_edit = QTextEdit(self)
        self.text_edit.setReadOnly(True)

        # Ï†ÑÏ≤¥ Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
        self.layout.addLayout(top_row)
        self.layout.addLayout(bottom_row)
        self.layout.addLayout(time_row)  # Ï¢ÖÎ£å ÏãúÍ∞Ñ UI Ï∂îÍ∞Ä
        self.layout.addLayout(button_row)
        self.layout.addWidget(self.text_edit)
        self.setLayout(self.layout)

        # Í∞êÏãú ÌÉÄÏù¥Î®∏ ÏÑ§Ï†ï
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.fetch_prices)

        self.end_time = None  # Ï¢ÖÎ£å ÏãúÍ∞ÑÏùÑ Ï¥àÍ∏∞Ìôî

    def format_amount_input(self):
        text = self.order_amount_input.text().replace(",", "")
        if text.isdigit():
            formatted = f"{int(text):,}"
            self.order_amount_input.blockSignals(True)
            self.order_amount_input.setText(formatted)
            self.order_amount_input.blockSignals(False)
        elif not text:  # ÏûÖÎ†•Ïù¥ ÏóÜÎäî Í≤ΩÏö∞
            self.order_amount_input.blockSignals(True)
            self.order_amount_input.setText("")
            self.order_amount_input.blockSignals(False)

    def start_trading(self):
        try:
            self.watch_code = self.watch_code_input.text().strip()
            self.order_code = self.order_code_input.text().strip()
            self.option_trigger_price = float(self.trigger_price_input.text())
            # Ï£ºÎ¨∏ Í∏àÏï° ÏûÖÎ†•Í∞íÏù¥ ÎπÑÏñ¥ÏûàÍ±∞ÎÇò, Ïà´ÏûêÍ∞Ä ÏïÑÎãàÍ±∞ÎÇò, 0Ïùº Í≤ΩÏö∞ Ï≤òÎ¶¨
            order_amount_text = self.order_amount_input.text().replace(",", "")
            if not order_amount_text or not order_amount_text.isdigit() or int(order_amount_text) == 0:
                self.text_edit.append("‚ùå Ï£ºÎ¨∏ Í∏àÏï°ÏùÑ Ïò¨Î∞îÎ•¥Í≤å ÏûÖÎ†•ÌïòÏÑ∏Ïöî (0Î≥¥Îã§ ÌÅ∞ Ïà´Ïûê).")
                return
            self.order_amount = int(order_amount_text)

            self.order_type = self.order_type_combo.currentText()

            if not self.watch_code or not self.order_code:
                self.text_edit.append("‚ùå ÏòµÏÖò ÏΩîÎìúÎ•º Î™®Îëê ÏûÖÎ†•ÌïòÏÑ∏Ïöî.")
                return

            # Í∞êÏãú Ï¢ÖÎ£å ÏãúÍ∞ÑÏùÑ ÏÑ§Ï†ï
            end_hour = int(self.end_hour_combo.currentText())
            end_minute = int(self.end_minute_combo.currentText())
            end_second = 0  # Ï¥àÎäî 0ÏúºÎ°ú ÏÑ§Ï†ï (Îß§ Î∂Ñ Îã®ÏúÑ Ï¢ÖÎ£å)
            self.end_time = QTime(end_hour, end_minute, end_second)

            self.text_edit.append("\nüìå [Í∞êÏãú ÏÑ§Ï†ï ÏãúÏûë]")
            self.text_edit.append(f"üìç Í∞êÏãú ÏòµÏÖò ÏΩîÎìú: {self.watch_code}")
            self.text_edit.append(f"üìç Ìä∏Î¶¨Í±∞ Í∞ÄÍ≤©: {self.option_trigger_price:.2f}")
            self.text_edit.append(f"üìç Ï£ºÎ¨∏ ÏòµÏÖò ÏΩîÎìú: {self.order_code}")
            self.text_edit.append(f"üìç Ï£ºÎ¨∏ Í∏àÏï°: {self.order_amount:,} Ïõê")
            self.text_edit.append(f"üìç Ï£ºÎ¨∏ Ïú†Ìòï: {'Îß§Ïàò' if self.order_type == 'buy' else 'Îß§ÎèÑ'}")
            self.text_edit.append(f"‚è± Í∞êÏãú ÏãúÏûë (Ïù∏ÌÑ∞Î≤å: {self.interval_combo.currentText()}Ï¥à)...\n")

            self.last_log_time = 0  # ÏãúÏûë Ïãú ÎßàÏßÄÎßâ Î°úÍ∑∏ ÏãúÍ∞Ñ Ï¥àÍ∏∞Ìôî
            self.previous_watch_price = None  # Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë Ïãú Ïù¥Ï†Ñ Í∞ÄÍ≤© Ï¥àÍ∏∞Ìôî
            self.timer.start(int(self.interval_combo.currentText()) * 1000)
        except ValueError:
            self.text_edit.append("‚ùå ÏûÖÎ†• Ïò§Î•ò: Ïà´Ïûê ÌòïÏãùÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.")

    def stop_trading(self):
        self.timer.stop()
        self.text_edit.append("üõë Í∞êÏãú Ï§ëÏßÄÎê®.\n")

    def fetch_prices(self):
        current_time_val = time.time()  # time.time()ÏùÄ float Î∞òÌôò
        interval_seconds = int(self.interval_combo.currentText())  # ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ†ÌÉùÌïú Ïù∏ÌÑ∞Î≤å (Ï¥à)

        # QTimerÏùò Ïù∏ÌÑ∞Î≤åÏùÄ Î∞ÄÎ¶¨Ï¥à Îã®ÏúÑ, fetch_pricesÎäî QTimerÏóê ÏùòÌï¥ Ìò∏Ï∂úÎê®
        # Î°úÍ∑∏ Í∏∞Î°ùÏùÄ ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ§Ï†ïÌïú Ï¥à(interval_seconds) Îã®ÏúÑÎ°ú Ï†úÏñ¥

        watch_price = get_current_price(self.watch_code)
        order_price = get_current_price(self.order_code)
        timestamp = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(current_time_val))

        if isinstance(watch_price, float) and isinstance(order_price, float):
            formatted_watch_price = f"{watch_price:.2f}"
            formatted_order_price = f"{order_price:.2f}"

            # Î°úÍ∑∏ Í∏∞Î°ù (ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ§Ï†ïÌïú interval_secondsÎßàÎã§)
            if self.last_log_time == 0 or (current_time_val - self.last_log_time >= interval_seconds):
                self.log_count += 1
                background = "#f0f0f0" if self.log_count % 2 == 0 else "transparent"
                snapshot_line = (
                    f"<div style='background-color:{background}; padding:2px;'>"
                    f"[{timestamp}] Í∞êÏãú({self.watch_code}): {formatted_watch_price} | "
                    f"Ï£ºÎ¨∏({self.order_code}): {formatted_order_price}"
                    f"</div>"
                )
                self.text_edit.append(snapshot_line)
                self.last_log_time = current_time_val  # ÎßàÏßÄÎßâ Î°úÍ∑∏ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏

            # Ìä∏Î¶¨Í±∞ Í∞ÄÍ≤© Í∞êÏßÄ Î∞è Ï£ºÎ¨∏ Î°úÏßÅ
            triggered = False
            trigger_reason = ""  # Ìä∏Î¶¨Í±∞ ÏÇ¨Ïú† Ï†ÄÏû• Î≥ÄÏàò

            if self.previous_watch_price is not None and self.option_trigger_price is not None:
                # ÏïÑÎûòÏóêÏÑú ÏúÑÎ°ú ÌÜµÍ≥º (Ïù¥Ï†Ñ Í∞ÄÍ≤© < Ìä∏Î¶¨Í±∞ Í∞ÄÍ≤© < ÌòÑÏû¨ Í∞ÄÍ≤©)
                if self.previous_watch_price < self.option_trigger_price and watch_price > self.option_trigger_price:
                    trigger_log_msg = "\nüîî [Ìä∏Î¶¨Í±∞ Í∞êÏßÄ] (ÏïÑÎûò ‚Üí ÏúÑ ÌÜµÍ≥º)"
                    self.text_edit.append(trigger_log_msg)
                    triggered = True
                    trigger_reason = "ÏïÑÎûò ‚Üí ÏúÑ ÌÜµÍ≥º"
                # ÏúÑÏóêÏÑú ÏïÑÎûòÎ°ú ÌÜµÍ≥º (Ïù¥Ï†Ñ Í∞ÄÍ≤© > Ìä∏Î¶¨Í±∞ Í∞ÄÍ≤© > ÌòÑÏû¨ Í∞ÄÍ≤©)
                elif self.previous_watch_price > self.option_trigger_price and watch_price < self.option_trigger_price:
                    trigger_log_msg = "\nüîî [Ìä∏Î¶¨Í±∞ Í∞êÏßÄ] (ÏúÑ ‚Üí ÏïÑÎûò ÌÜµÍ≥º)"
                    self.text_edit.append(trigger_log_msg)
                    triggered = True
                    trigger_reason = "ÏúÑ ‚Üí ÏïÑÎûò ÌÜµÍ≥º"
                # Ï†ïÌôïÌûà Ìä∏Î¶¨Í±∞ Í∞ÄÍ≤©Ïóê ÎèÑÎã¨ (ÌòÑÏû¨ Í∞ÄÍ≤©Ïù¥ Ìä∏Î¶¨Í±∞ Í∞ÄÍ≤©Í≥º Í±∞Ïùò Í∞ôÏùå)
                elif abs(watch_price - self.option_trigger_price) < 0.001:  # Îçî ÏûëÏùÄ ÌóàÏö© Ïò§Ï∞®
                    # Îã®, Ïù¥Ï†Ñ Í∞ÄÍ≤©Ïù¥ Ìä∏Î¶¨Í±∞ Í∞ÄÍ≤©Í≥º Í∞ôÏßÄ ÏïäÏïÑÏïº Ï≤òÏùå ÎèÑÎã¨Ìïú Í≤ÉÏúºÎ°ú Í∞ÑÏ£º (ÏÑ†ÌÉùÏ†Å)
                    if self.previous_watch_price is None or abs(
                            self.previous_watch_price - self.option_trigger_price) >= 0.001:
                        trigger_log_msg = "\nüîî [Ìä∏Î¶¨Í±∞ Í∞êÏßÄ] (Ï†ïÌôïÌûà ÎèÑÎã¨)"
                        self.text_edit.append(trigger_log_msg)
                        triggered = True
                        trigger_reason = "Ï†ïÌôïÌûà ÎèÑÎã¨"

            if triggered:
                quantity = int(self.order_amount // (order_price * self.contract_unit))

                # UI Î°úÍ∑∏ Ï∂îÍ∞Ä
                self.text_edit.append(f"‚è∞ Í∞êÏßÄ ÏãúÍ∞Ñ: {timestamp}")
                self.text_edit.append(
                    f"üéØ Í∞êÏãú ÏòµÏÖò ({self.watch_code}) Ìä∏Î¶¨Í±∞ Ïãú Í∞ÄÍ≤©: {formatted_watch_price}")  # Ìä∏Î¶¨Í±∞ ÏãúÏ†êÏùò Í∞êÏãú ÏòµÏÖò Í∞ÄÍ≤©
                self.text_edit.append(f"üõí Ï£ºÎ¨∏ ÏòµÏÖò ({self.order_code}) ÌòÑÏû¨ Í∞ÄÍ≤©: {formatted_order_price}")  # Ï£ºÎ¨∏ ÏòµÏÖòÏùò ÌòÑÏû¨ Í∞ÄÍ≤©
                self.text_edit.append(f"üí∞ Í≥ÑÏÇ∞Îêú Ï£ºÎ¨∏ ÏàòÎüâ: {quantity} (Ï£ºÎ¨∏ Í∏àÏï° Í∏∞Ï§Ä)")
                self.text_edit.append(f"üì§ Ï£ºÎ¨∏ Ïú†Ìòï: {'Îß§Ïàò' if self.order_type == 'buy' else 'Îß§ÎèÑ'}")

                # --- ÌÖîÎ†àÍ∑∏Îû® Î©îÏãúÏßÄ Ï†ÑÏÜ° ---
                telegram_msg = (
                    f"[OrderA_ReachB ÏïåÎ¶º]\n"
                    f"üîî Ìä∏Î¶¨Í±∞ Î∞úÏÉù! ({trigger_reason})\n"
                    f"‚è∞ ÏãúÍ∞Ñ: {timestamp}\n"
                    f"üëÄ Í∞êÏãú ÏòµÏÖò: {self.watch_code}\n"
                    f"   - Ìä∏Î¶¨Í±∞ Í∞ÄÍ≤©: {self.option_trigger_price:.2f}\n"
                    f"   - ÌòÑÏû¨Í∞Ä: {formatted_watch_price}\n"
                    f"üõçÔ∏è Ï£ºÎ¨∏ ÏòµÏÖò: {self.order_code}\n"
                    f"   - ÌòÑÏû¨Í∞Ä: {formatted_order_price}\n"
                    f"   - Ï£ºÎ¨∏ Ïú†Ìòï: {'Îß§Ïàò' if self.order_type == 'buy' else 'Îß§ÎèÑ'}\n"
                    f"   - Ï£ºÎ¨∏ Í∏àÏï°: {self.order_amount:,} Ïõê\n"
                    f"   - ÏòàÏÉÅ ÏàòÎüâ: {quantity}"
                )

                if quantity > 0:
                    self.text_edit.append("üöÄ Ï£ºÎ¨∏ Ïã§Ìñâ ÏãúÎèÑ...")
                    telegram_msg += "\n\nüöÄ Ï£ºÎ¨∏ Ïã§Ìñâ ÏãúÎèÑ..."
                    try:
                        send_telegram_message(telegram_msg)
                        self.text_edit.append("‚úâÔ∏è ÌÖîÎ†àÍ∑∏Îû® ÏïåÎ¶º Ï†ÑÏÜ° ÏôÑÎ£å (Ï£ºÎ¨∏ ÏãúÎèÑ)")
                    except Exception as e:
                        self.text_edit.append(f"ÌÖîÎ†àÍ∑∏Îû® ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®: {e}")
                    self.place_option_order(order_price, quantity)
                else:
                    self.text_edit.append("‚ö†Ô∏è Ï£ºÎ¨∏ ÏàòÎüâÏù¥ 0ÏûÖÎãàÎã§. Ï£ºÎ¨∏ÏùÑ Ïã§ÌñâÌïòÏßÄ ÏïäÏäµÎãàÎã§.")
                    telegram_msg += "\n\n‚ö†Ô∏è Ï£ºÎ¨∏ ÏàòÎüâ 0. Ï£ºÎ¨∏ ÎØ∏Ïã§Ìñâ."
                    try:
                        send_telegram_message(telegram_msg)
                        self.text_edit.append("‚úâÔ∏è ÌÖîÎ†àÍ∑∏Îû® ÏïåÎ¶º Ï†ÑÏÜ° ÏôÑÎ£å (Ï£ºÎ¨∏ ÎØ∏Ïã§Ìñâ)")
                    except Exception as e:
                        self.text_edit.append(f"ÌÖîÎ†àÍ∑∏Îû® ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®: {e}")
                    self.timer.stop()  # Ï£ºÎ¨∏ ÏàòÎüâÏù¥ 0Ïù¥Î©¥ ÌÉÄÏù¥Î®∏ Ï§ëÏßÄ

            self.previous_watch_price = watch_price  # ÌòÑÏû¨ Í∞êÏãú Í∞ÄÍ≤©ÏùÑ Ïù¥Ï†Ñ Í∞ÄÍ≤©ÏúºÎ°ú Ï†ÄÏû•

        else:
            error_msg = f"‚ö†Ô∏è Í∞ÄÍ≤© Ï°∞Ìöå Ïã§Ìå® - Í∞êÏãú({self.watch_code}): {watch_price}, Ï£ºÎ¨∏({self.order_code}): {order_price}"
            self.text_edit.append(error_msg)
            # Optionally send a Telegram message for price fetch failure if persistent
            # try:
            #     send_telegram_message(f"[OrderA_ReachB Ïò§Î•ò]\n{error_msg}")
            # except Exception as e:
            #     self.text_edit.append(f"ÌÖîÎ†àÍ∑∏Îû® (Ïò§Î•ò) ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®: {e}")
            self.previous_watch_price = None  # Í∞ÄÍ≤© Ï°∞Ìöå Ïã§Ìå® Ïãú Ïù¥Ï†Ñ Í∞ÄÍ≤© Ï†ïÎ≥¥ Ï¥àÍ∏∞Ìôî

        # Í∞êÏãú Ï¢ÖÎ£å ÏãúÍ∞Ñ ÌôïÏù∏
        if self.end_time is not None and QTime.currentTime() >= self.end_time:
            self.text_edit.append("\n‚è±Ô∏è Í∞êÏãú Ï¢ÖÎ£å ÏãúÍ∞ÑÏóê ÎèÑÎã¨ÌïòÏó¨ Î™®ÎãàÌÑ∞ÎßÅÏùÑ Ï§ëÏßÄÌï©ÎãàÎã§.")
            self.stop_trading()
            try:
                send_telegram_message("[OrderA_ReachB ÏïåÎ¶º]\n‚è±Ô∏è Í∞êÏãú Ï¢ÖÎ£å ÏãúÍ∞ÑÏóê ÎèÑÎã¨ÌïòÏó¨ Î™®ÎãàÌÑ∞ÎßÅÏùÑ Ï§ëÏßÄÌï©ÎãàÎã§.")
            except Exception as e:
                self.text_edit.append(f"ÌÖîÎ†àÍ∑∏Îû® (Ï¢ÖÎ£å) ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®: {e}")

    def place_option_order(self, initial_price, total_quantity):
        objOrder = CpFutureOptionOrder()
        split_quantity_base = total_quantity // 3
        remaining_quantity_after_split = total_quantity % 3

        self.text_edit.append("\nüì¶ [Î∂ÑÌï† Ï£ºÎ¨∏ Ï≤òÎ¶¨ ÏãúÏûë]")
        self.text_edit.append(f"üìù Ï¥ù Ï£ºÎ¨∏ ÏàòÎüâ: {total_quantity}")
        self.text_edit.append(f"Ï™ºÍ∞úÏßÑ Ï£ºÎ¨∏ ÏàòÎüâ (Í∏∞Î≥∏): {split_quantity_base} (ÎÇòÎ®∏ÏßÄ: {remaining_quantity_after_split})")

        # ÌÖîÎ†àÍ∑∏Îû® Î©îÏãúÏßÄ Ï¥àÍ∏∞Ìôî (Î∂ÑÌï† Ï£ºÎ¨∏ ÏãúÏûë ÏïåÎ¶º)
        telegram_order_details = [f"\n\nüì¶ [Î∂ÑÌï† Ï£ºÎ¨∏ Ï≤òÎ¶¨ ÏãúÏûë] (Ï¥ù {total_quantity}Í∞ú)"]

        for i in range(3):
            current_order_quantity = split_quantity_base
            if i < remaining_quantity_after_split:
                current_order_quantity += 1

            if current_order_quantity > 0:
                order_price_adj = initial_price  # Í∏∞Ï§Ä Í∞ÄÍ≤©ÏùÄ Ï£ºÎ¨∏ ÏòµÏÖòÏùò ÌòÑÏû¨Í∞Ä
                order_type_str_display = ""

                if self.order_type == 'buy':
                    order_price_adj += 0.01 * i
                    order_type_str_display = "Îß§Ïàò"
                else:  # sell
                    order_price_adj -= 0.01 * i
                    order_type_str_display = "Îß§ÎèÑ"

                # Í∞ÄÍ≤©Ïù¥ ÏùåÏàòÍ∞Ä ÎêòÏßÄ ÏïäÎèÑÎ°ù Î≥¥Ï†ï (ÏµúÏÜå 0.01)
                order_price_adj = max(0.01, order_price_adj)
                formatted_price_adj = f"{order_price_adj:.2f}"

                retOrder = {}
                success = False

                order_attempt_log = f"\nüì§ [{i + 1}/3] {order_type_str_display} Î∂ÑÌï† Ï£ºÎ¨∏ ÏãúÎèÑ (ÏàòÎüâ: {current_order_quantity}, Í∞ÄÍ≤©: {formatted_price_adj})"
                self.text_edit.append(order_attempt_log)
                telegram_order_details.append(order_attempt_log.replace("\n", ""))

                if self.order_type == 'buy':
                    success = objOrder.buyOrder(self.order_code, order_price_adj, current_order_quantity, retOrder)
                else:  # sell
                    success = objOrder.sellOrder(self.order_code, order_price_adj, current_order_quantity, retOrder)

                if success:
                    success_log = (
                        f"‚úÖ {order_type_str_display} Ï£ºÎ¨∏ ÏÑ±Í≥µ!\n"
                        f"üü¢ Ï£ºÎ¨∏ ÏòµÏÖò: {self.order_code}\n"
                        f"üìä ÏàòÎüâ: {current_order_quantity} | Í∞ÄÍ≤©: {formatted_price_adj}\n"
                        f"üì® Ï£ºÎ¨∏ ÏùëÎãµ: {retOrder}"
                    )
                    self.text_edit.append(success_log)
                    telegram_order_details.append(f"  ‚úÖ ÏÑ±Í≥µ! ÏùëÎãµ: {retOrder}")
                else:
                    fail_log = (
                        f"‚ùå {order_type_str_display} Ï£ºÎ¨∏ Ïã§Ìå®\n"
                        f"üì® Ï£ºÎ¨∏ ÏùëÎãµ: {retOrder}"
                    )
                    self.text_edit.append(fail_log)
                    telegram_order_details.append(f"  ‚ùå Ïã§Ìå®. ÏùëÎãµ: {retOrder}")
            else:
                no_qty_log = f"\n‚ö†Ô∏è [{i + 1}/3] Ï£ºÎ¨∏Ìï† ÏàòÎüâÏù¥ ÏóÜÏäµÎãàÎã§."
                self.text_edit.append(no_qty_log)
                telegram_order_details.append(no_qty_log.replace("\n", "") + " (Ìï¥Îãπ Ï∞®Ïàò Í±¥ÎÑàÎúÄ)")

        # Î∂ÑÌï† Ï£ºÎ¨∏ Í≤∞Í≥º ÌÖîÎ†àÍ∑∏Îû® Ï†ÑÏÜ°
        try:
            final_telegram_msg = "\n".join(telegram_order_details)
            send_telegram_message(f"[OrderA_ReachB Ï£ºÎ¨∏ Í≤∞Í≥º]\n{final_telegram_msg}")
            self.text_edit.append("‚úâÔ∏è ÌÖîÎ†àÍ∑∏Îû®ÏúºÎ°ú Î∂ÑÌï† Ï£ºÎ¨∏ Í≤∞Í≥º Ï†ÑÏÜ° ÏôÑÎ£å.")
        except Exception as e:
            self.text_edit.append(f"ÌÖîÎ†àÍ∑∏Îû® (Î∂ÑÌï† Ï£ºÎ¨∏ Í≤∞Í≥º) ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®: {e}")

        self.timer.stop()  # Î™®Îì† Î∂ÑÌï† Ï£ºÎ¨∏ ÏãúÎèÑ ÌõÑ ÌÉÄÏù¥Î®∏ Ï§ëÏßÄ


if __name__ == "__main__":
    # Comms_Class.pyÏóê ÏûàÎäî BOT_TOKENÍ≥º CHAT_IDÍ∞Ä ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÏÑ∏Ïöî.
    # Ïòà:
    # if not Comms_Class.BOT_TOKEN or not Comms_Class.CHAT_ID:
    #     print("ÌÖîÎ†àÍ∑∏Îû® BOT_TOKEN ÎòêÎäî CHAT_IDÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Comms_Class.py ÌååÏùºÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.")
    #     # exit() # ÌïÑÏöîÏãú Ï¢ÖÎ£å

    if not InitPlusCheck():
        # InitPlusCheck ÎÇ¥Î∂ÄÏóêÏÑú Ïù¥ÎØ∏ printÎ°ú Ïò§Î•òÎ•º ÏïåÎ¶¨ÎØÄÎ°ú, Ï∂îÍ∞Ä Î©îÏãúÏßÄ ÏóÜÏù¥ Ï¢ÖÎ£å
        exit()

    app = QApplication(sys.argv)
    window = FutureOptionApp()
    window.show()
    sys.exit(app.exec_())